"""
Brain Agent - The continuously running AI that learns and thinks.

This is the main orchestrator that:
1. Runs on a schedule (or continuously)
2. Observes new data
3. Forms and tests hypotheses
4. Learns from outcomes
5. Generates actionable recommendations
6. Consolidates memory over time

Think of it as a retail analyst that never sleeps,
always watching the data, always learning.
"""

import json
import time
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import Optional, Callable
from pathlib import Path
import threading
import requests

from aoc_analytics.core.db_adapter import get_connection
from aoc_analytics.brain.memory import BrainMemory, MemoryEntry, Hypothesis
from aoc_analytics.brain.learner import KnowledgeLearner
from aoc_analytics.brain.hypothesis import HypothesisEngine


@dataclass
class BrainState:
    """Current state of the brain."""
    is_running: bool = False
    last_observation: Optional[datetime] = None
    last_hypothesis_test: Optional[datetime] = None
    last_learning: Optional[datetime] = None
    observations_today: int = 0
    hypotheses_tested_today: int = 0
    insights_generated: int = 0


@dataclass
class DailyInsight:
    """An insight generated by the brain."""
    id: str
    timestamp: datetime
    insight_type: str  # 'recommendation', 'warning', 'observation'
    title: str
    content: str
    confidence: float
    supporting_evidence: list = field(default_factory=list)
    actionable: bool = True


class BrainAgent:
    """
    The autonomous learning agent.
    
    Usage:
        brain = BrainAgent()
        brain.wake_up()  # Initialize and load knowledge
        
        # Option 1: Run continuously
        brain.run_forever()
        
        # Option 2: Run single cycle
        brain.think_cycle()
        
        # Get recommendations
        insights = brain.get_todays_insights()
    """
    
    def __init__(self, 
                 sales_db: str = "aoc_sales.db",
                 brain_db: str = "brain_memory.db",
                 ollama_url: str = "http://localhost:11434"):
        
        self.sales_db = Path(sales_db)
        self.brain_db = Path(brain_db)
        self.ollama_url = ollama_url
        
        # Initialize components
        self.memory = BrainMemory(str(self.brain_db))
        self.learner = KnowledgeLearner(self.memory, ollama_url)
        self.hypothesis_engine = HypothesisEngine(
            self.memory, 
            str(self.sales_db),
            ollama_url
        )
        
        self.state = BrainState()
        self._stop_flag = threading.Event()
        self._insights_today: list[DailyInsight] = []
    
    def wake_up(self):
        """
        Initialize the brain - load fundamental knowledge if first run.
        """
        print("ðŸ§  Brain waking up...")
        
        # Check if this is first run
        stats = self.memory.get_stats()
        total_memories = sum(
            cat.get('count', 0) 
            for cat in stats.get('memories', {}).values()
        )
        
        if total_memories == 0:
            print("  First run detected - bootstrapping knowledge...")
            self.learner.bootstrap_fundamentals()
        else:
            print(f"  Loaded existing memory: {total_memories} memories")
        
        # Load hypothesis stats
        h_stats = stats.get('hypotheses', {})
        print(f"  Hypotheses: {h_stats.get('validated', 0)} validated, "
              f"{h_stats.get('testing', 0)} testing, "
              f"{h_stats.get('untested', 0)} untested")
        
        self.state.is_running = True
        print("âœ“ Brain is awake and ready")
    
    def think_cycle(self) -> list[DailyInsight]:
        """
        Run one complete think cycle:
        1. Observe current data
        2. Check for patterns
        3. Test any applicable hypotheses
        4. Generate new hypotheses from observations
        5. Synthesize insights
        
        Returns insights generated this cycle.
        """
        cycle_insights = []
        now = datetime.now()
        
        print(f"\nðŸ”„ Think cycle at {now.strftime('%H:%M:%S')}")
        
        # === STEP 1: OBSERVE ===
        observations = self._observe_current_state()
        self.state.last_observation = now
        self.state.observations_today += len(observations)
        
        if observations:
            print(f"  ðŸ“Š Made {len(observations)} observations")
        
        # === STEP 2: TEST HYPOTHESES ===
        testable = self.hypothesis_engine.get_todays_testable_hypotheses()
        if testable:
            print(f"  ðŸ§ª Testing {len(testable)} hypotheses...")
            for h in testable[:5]:  # Limit per cycle
                result = self._test_hypothesis(h)
                if result:
                    self.state.hypotheses_tested_today += 1
                    if result.prediction_correct:
                        print(f"    âœ“ Validated: {h.statement[:50]}...")
                    else:
                        print(f"    âœ— Disproven: {h.statement[:50]}...")
        
        self.state.last_hypothesis_test = now
        
        # === STEP 3: GENERATE NEW HYPOTHESES ===
        if now.hour == 23:  # Once per day, analyze for new patterns
            print("  ðŸ’¡ Generating new hypotheses from patterns...")
            new_hypotheses = self.hypothesis_engine.generate_hypotheses_from_data()
            print(f"    Created {len(new_hypotheses)} new hypotheses")
        
        # === STEP 4: SYNTHESIZE INSIGHTS ===
        if now.hour in [9, 14, 18]:  # Generate insights 3x per day
            insights = self._generate_insights()
            cycle_insights.extend(insights)
            self._insights_today.extend(insights)
            self.state.insights_generated += len(insights)
            
            for insight in insights:
                print(f"  ðŸ’Ž Insight: {insight.title}")
        
        # === STEP 5: MEMORY MAINTENANCE ===
        if now.hour == 3:  # Consolidate at 3am
            print("  ðŸ§¹ Consolidating memory...")
            self.memory.consolidate(keep_top_n=2000)
        
        return cycle_insights
    
    def _observe_current_state(self) -> list[dict]:
        """Observe current sales patterns and anomalies."""
        observations = []
        
        conn = get_connection(str(self.sales_db))
        now = datetime.now()
        today = now.strftime('%Y-%m-%d')
        
        # Check today's sales vs expectation
        today_sales = conn.execute("""
            SELECT SUM(subtotal) as revenue, COUNT(DISTINCT invoice_id) as txns
            FROM sales WHERE date = ?
        """, (today,)).fetchone()
        
        if today_sales[0]:
            # Compare to same DOW average
            dow = now.strftime('%w')
            expected = conn.execute("""
                SELECT AVG(daily_rev) FROM (
                    SELECT SUM(subtotal) as daily_rev
                    FROM sales 
                    WHERE strftime('%w', date) = ?
                    AND date >= date('now', '-90 days')
                    AND date < date('now')
                    GROUP BY date
                )
            """, (dow,)).fetchone()[0]
            
            if expected:
                pct_diff = ((today_sales[0] - expected) / expected) * 100
                
                if abs(pct_diff) > 15:
                    direction = "above" if pct_diff > 0 else "below"
                    observations.append({
                        'type': 'daily_anomaly',
                        'description': f"Today's sales are {abs(pct_diff):.1f}% {direction} expected",
                        'data': {
                            'actual': today_sales[0],
                            'expected': expected,
                            'pct_diff': pct_diff
                        }
                    })
                    
                    # Store as memory
                    entry = MemoryEntry(
                        id=self.memory._generate_id(f"anomaly_{today}", "obs"),
                        category="observation",
                        content=f"On {today}, sales were {abs(pct_diff):.1f}% {direction} expected (${today_sales[0]:,.0f} vs ${expected:,.0f} expected)",
                        source="daily_observation",
                        confidence=0.7,
                        metadata={
                            'date': today,
                            'actual': today_sales[0],
                            'expected': expected,
                            'pct_diff': pct_diff
                        }
                    )
                    self.memory.store_memory(entry)
        
        conn.close()
        return observations
    
    def _test_hypothesis(self, h: Hypothesis) -> Optional[dict]:
        """Test a specific hypothesis against current data."""
        conn = get_connection(str(self.sales_db))
        today = datetime.now().strftime('%Y-%m-%d')
        
        # Get today's value for the metric
        if 'category' in h.conditions:
            actual = conn.execute("""
                SELECT SUM(subtotal) FROM sales 
                WHERE date = ? AND category = ?
            """, (today, h.conditions['category'])).fetchone()[0]
            
            baseline = conn.execute("""
                SELECT AVG(cat_rev) FROM (
                    SELECT SUM(subtotal) as cat_rev
                    FROM sales 
                    WHERE category = ?
                    AND date >= date('now', '-30 days')
                    AND date < date('now')
                    GROUP BY date
                )
            """, (h.conditions['category'],)).fetchone()[0]
        else:
            actual = conn.execute("""
                SELECT SUM(subtotal) FROM sales WHERE date = ?
            """, (today,)).fetchone()[0]
            
            baseline = conn.execute("""
                SELECT AVG(daily_rev) FROM (
                    SELECT SUM(subtotal) as daily_rev
                    FROM sales 
                    WHERE date >= date('now', '-30 days')
                    AND date < date('now')
                    GROUP BY date
                )
            """).fetchone()[0]
        
        conn.close()
        
        if not actual or not baseline:
            return None
        
        return self.hypothesis_engine.test_hypothesis(h, actual, baseline)
    
    def _generate_insights(self) -> list[DailyInsight]:
        """Generate actionable insights from validated knowledge."""
        insights = []
        
        # Insight from validated hypotheses
        h_insight = self.hypothesis_engine.generate_insight_from_validated()
        if h_insight:
            insights.append(DailyInsight(
                id=self.memory._generate_id(h_insight, "ins"),
                timestamp=datetime.now(),
                insight_type="recommendation",
                title="Pattern-Based Recommendation",
                content=h_insight,
                confidence=0.7,
                actionable=True
            ))
        
        # Check if any retail principles apply to current situation
        relevant = self.learner.get_relevant_knowledge(
            f"Today is {datetime.now().strftime('%A')}, it's {datetime.now().hour}:00"
        )
        
        for mem in relevant[:2]:
            if mem.confidence > 0.6:
                insights.append(DailyInsight(
                    id=self.memory._generate_id(mem.content, "ins"),
                    timestamp=datetime.now(),
                    insight_type="reminder",
                    title=mem.metadata.get('name', 'Principle Reminder'),
                    content=mem.content,
                    confidence=mem.confidence,
                    actionable=True
                ))
        
        return insights
    
    def get_todays_insights(self) -> list[DailyInsight]:
        """Get all insights generated today."""
        return self._insights_today
    
    def ask(self, question: str) -> str:
        """
        Ask the brain a question.
        
        Uses accumulated knowledge and validated hypotheses to answer.
        """
        # Recall relevant knowledge
        knowledge = self.memory.recall(question, category="knowledge", limit=5)
        observations = self.memory.recall(question, category="observation", limit=3)
        validated = self.memory.get_validated_hypotheses()[:5]
        
        # Build context
        context = "RELEVANT KNOWLEDGE:\n"
        for k in knowledge:
            context += f"- {k.content}\n"
        
        context += "\nOBSERVATIONS FROM OUR DATA:\n"
        for o in observations:
            context += f"- {o.content}\n"
        
        context += "\nVALIDATED PATTERNS:\n"
        for h in validated:
            context += f"- {h.statement} ({h.confidence:.0%} confident, {h.accuracy:.0%} accurate)\n"
        
        prompt = f"""You are AOC's retail intelligence system. Answer this question using only the context provided.

{context}

QUESTION: {question}

Answer concisely and specifically. If the answer requires data you don't have, say so.
"""
        
        response = requests.post(
            f"{self.ollama_url}/api/generate",
            json={
                "model": "llama3.2",
                "prompt": prompt,
                "stream": False,
                "options": {"temperature": 0.3}
            },
            timeout=30
        )
        
        if response.status_code == 200:
            return response.json()['response']
        return "I couldn't process that question right now."
    
    def run_forever(self, cycle_interval_minutes: int = 60):
        """
        Run the brain continuously.
        
        Executes think cycles at the specified interval.
        """
        print(f"\nðŸ§  Brain entering continuous mode (cycle every {cycle_interval_minutes}m)")
        print("   Press Ctrl+C to stop\n")
        
        self._stop_flag.clear()
        
        try:
            while not self._stop_flag.is_set():
                self.think_cycle()
                
                # Wait for next cycle
                for _ in range(cycle_interval_minutes * 60):
                    if self._stop_flag.is_set():
                        break
                    time.sleep(1)
                    
        except KeyboardInterrupt:
            print("\n\nðŸ›‘ Brain shutting down...")
        finally:
            self.sleep()
    
    def stop(self):
        """Signal the brain to stop."""
        self._stop_flag.set()
    
    def sleep(self):
        """Put the brain to sleep - save state and close connections."""
        print("ðŸ’¤ Brain going to sleep...")
        self.memory.close()
        self.state.is_running = False
    
    def get_status(self) -> dict:
        """Get current brain status."""
        stats = self.memory.get_stats()
        h_summary = self.hypothesis_engine.get_hypothesis_summary()
        
        return {
            'is_running': self.state.is_running,
            'last_observation': self.state.last_observation.isoformat() if self.state.last_observation else None,
            'observations_today': self.state.observations_today,
            'hypotheses_tested_today': self.state.hypotheses_tested_today,
            'insights_generated': self.state.insights_generated,
            'memory_stats': stats,
            'hypothesis_summary': h_summary,
            'todays_insights': len(self._insights_today),
        }


# === DEMO / CLI ===

def demo():
    """Demo the brain capabilities."""
    import os
    
    # Use the actual sales database
    sales_db = "/home/macklemoron/Projects/aoc-analytics/aoc_sales.db"
    brain_db = "/home/macklemoron/Projects/aoc-analytics/brain_memory.db"
    
    print("=" * 60)
    print("AOC BRAIN - Autonomous Learning Agent Demo")
    print("=" * 60)
    
    # Initialize brain
    brain = BrainAgent(sales_db=sales_db, brain_db=brain_db)
    brain.wake_up()
    
    # Run one think cycle
    print("\n" + "=" * 60)
    print("Running think cycle...")
    print("=" * 60)
    insights = brain.think_cycle()
    
    # Show status
    print("\n" + "=" * 60)
    print("Brain Status")
    print("=" * 60)
    status = brain.get_status()
    print(json.dumps(status, indent=2, default=str))
    
    # Ask a question
    print("\n" + "=" * 60)
    print("Asking the brain a question...")
    print("=" * 60)
    answer = brain.ask("What day of the week has the best sales?")
    print(f"\nQ: What day of the week has the best sales?")
    print(f"A: {answer}")
    
    # Clean up
    brain.sleep()


if __name__ == "__main__":
    demo()
